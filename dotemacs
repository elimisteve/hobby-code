;;; This was installed by package-install.el.
;;; This provides support for the package system and
;;; interfacing with ELPA, the package archive.
;;; Move this code earlier if you want to reference
;;; packages in your .emacs.
(when
    (load
     (expand-file-name "~/.emacs.d/elpa/package.el"))
  (package-initialize))

;;emacs color themes are in the package emacs-goodies-el on ubuntu
(require 'color-theme)
(color-theme-initialize)
;;here are the ones I find usable
(color-theme-billw)
;(color-theme-gtk-ide)
;(color-theme-katester)
;(color-theme-midnight)
;(color-theme-retro-green)
;(color-theme-retro-orange)
;(color-theme-scintilla)

;;lisp editing is better with flashing brackets
(show-paren-mode)

;no line wrapping ;modified for dev8d
(setq-default truncate-lines nil)

;set fill column for netbook screen
(setq-default fill-column 80)

;don't scroll like a tard. duh.
(setq scroll-conservatively 10000)

; make a copy for backup rather than moving the file and writing a new one.
; means that hard links survive editing.
(setq backup-by-copying t)

; make emacs use the clipboard
(setq x-select-enable-clipboard t)
(setq interprogram-paste-function 'x-cut-buffer-or-selection-value)


;make the set-fill-column key, which I never use, go away and stop
;interfering with C-x C-f for find-file
(global-set-key (kbd "C-x f") 'find-file)

;these only started working after I disabled all the GNOME A-C-arrow etc keys.
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)

;whitespace highlighting is useful for python, but annoying usually
;(global-whitespace-mode)

(setq-default indent-tabs-mode nil)

;; disable overwrite mode, so that accidentally hitting the insert key asks for confirmation
(put 'overwrite-mode 'disabled t)

;; ========== Place Backup Files in Specific Directory ==========
;; Enable backup files.
(setq make-backup-files t)
;; Enable versioning with default values (keep five last versions, I think!)
;; actually no, seems to only make the one
(setq version-control t)
;; Save all backup file in this directory.
(setq backup-directory-alist (quote ((".*" . "~/.emacs_backups/"))))

;; Put the full path of the file being edited in the titlebar
(setq frame-title-format '("%b" (buffer-file-name ": %f")))

;; Save the history of kills, and searches
(savehist-mode 1)
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))

;; disable bell function
(setq ring-bell-function 'ignore)
;; disable toolbar
(tool-bar-mode -1)
;; disable scrollbar
(toggle-scroll-bar -1)
;; disable menu bar
;(menu-bar-mode -1)
;; disable splash screen
(custom-set-variables '(inhibit-startup-screen t))
;; start emacs server
(server-start)

;; scala-mode
;; (add-to-list 'load-path "~/opt/scala-mode")
;; (require 'scala-mode)
;; (setq auto-mode-alist (cons '("\\.scala$" . scala-mode) auto-mode-alist))

;;clojure/slime/swank setup adapted from:
;;http://riddell.us/tutorial/slime_swank/slime_swank.html
;;################################################################

;; clojure-mode
;; (add-to-list 'load-path "~/opt/clojure-mode")
;;(require 'clojure-mode)

;; swank-clojure
;; (add-to-list 'load-path "~/opt/swank-clojure/src/emacs")

;;(setq swank-clojure-jar-path "~/.clojure/clojure.jar"
;;        swank-clojure-extra-classpaths (list
;;				      "~/.clojure/clojure-contrib.jar"
;;                                      "~/opt/swank-clojure/src/main/clojure"
;;				      ))

;; (require 'swank-clojure-autoload)

;; slime
;;(eval-after-load "slime"
;;  '(progn (slime-setup '(slime-repl))))
;;
;;(add-to-list 'load-path "~/opt/slime")

;;(slime-setup)

;;end of clojure/slime/swank setup from:
;;http://riddell.us/tutorial/slime_swank/slime_swank.html

;;bind the slime selector to f12 and add a method for finding clojure buffers
(require 'slime)
(define-key global-map (kbd "<f12>") 'slime-selector)
(def-slime-selector-method ?j
  "most recently visited clojure-mode buffer."
  (slime-recently-visited-buffer 'clojure-mode))


;;################################################################
;;################################################################
;;################################################################


;; to use the code from the book Programming Clojure, this fragment can be used
;; (swank-clojure-config
;;  (setq swank-clojure-jar-path "~/clojure-programs/programming-clojure/lib/clojure.jar")
;;  (setq swank-clojure-extra-classpaths
;;        (mapcar 
;; 	(lambda (s) (concat "~/clojure-programs/programming-clojure/" s)) 
;; 	(list "." 
;; 	      "lib/commons-io-1.4.jar" 
;; 	      "lib/commons-fileupload-1.2.1.jar"
;; 	      "lib/commons-codec-1.3.jar" 
;; 	      "lib/jline-0.9.94.jar"
;; 	      "lib/clojure.jar"
;; 	      "lib/clojure-contrib.jar"
;; 	      "lib/ant.jar:lib/ant-launcher.jar" 
;; 	      "lib/compojure.jar" 
;; 	      "lib/hsqldb.jar" 
;; 	      "lib/jetty-6.1.14.jar" 
;; 	      "lib/jetty-util-6.1.14.jar" 
;; 	      "lib/servlet-api-2.5-6.1.14.jar" 
;; 	      "classes"))))


;;for lensfield, it is better to use the maven-clojure-plugin to connect to a swank-server which will 
;;already have the relevant insanely long classpath.

;;copy last expression to repl
(defun copy-last-expression-to-clojure-slime-repl()
  "copy-last-expression-to-clojure-slime-repl. Not very clever about it. Finds buffer by name."
  (interactive)
  (let((end (point))
       (beg (save-excursion
              (backward-list 1)
              (point)))
       (edit-buffer (current-buffer))
       (lisp-buffer (get-buffer "*slime-repl clojure*"))
       (eval-command 'slime-repl-return))
  (progn
     (pop-to-buffer lisp-buffer)
     (end-of-buffer)
     (pop-to-buffer edit-buffer)
     (append-to-buffer lisp-buffer beg end)
     (pop-to-buffer lisp-buffer)
     (funcall eval-command)
     (pop-to-buffer edit-buffer))))

(define-key global-map (kbd "C-x C-r") 'copy-last-expression-to-clojure-slime-repl)

;;stolen from Steve Yegge at http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun swap-windows ()
  "If you have 2 windows, it swaps them." 
  (interactive) 
  (cond ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
        (t
         (let* ((w1 (first (window-list)))
                (w2 (second (window-list)))
                (b1 (window-buffer w1))
                (b2 (window-buffer w2))
                (s1 (window-start w1))
                (s2 (window-start w2)))
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (set-window-start w1 s2)
           (set-window-start w2 s1)))))

(define-key global-map (kbd "C-x C-8") 'swap-windows)

;;rainbow brackets
(add-to-list 'load-path "~/hobby-code")



(require 'highlight-parentheses)
(setq hl-paren-colors
      '(;"#8f8f8f" ; this comes from Zenburn
                   ; and I guess I'll try to make the far-outer parens look like this
        "orange1" "yellow1" "greenyellow" "green1"
        "springgreen1" "cyan1" "slateblue1" "magenta1" "purple"))

;(setq-default highlight-parentheses-mode t)
(add-hook 'clojure-mode-hook 
          (lambda () (highlight-parentheses-mode t)))

;; change assignment operator shortcut in ESS
;; (ess-toggle-underscore nil)


    (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
    (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
    (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)
    (setq prolog-system 'swi)
    (setq auto-mode-alist (append '(("\\.pl$" . prolog-mode)
                                    ("\\.m$" . mercury-mode))
                                   auto-mode-alist))
    
;; I occasionally find myself needing to gather lines up one by one and paste them all somewhere
;; You can do C-space, end, Cxx, M-C-w, M-w to get an appending yanking version of C-k
;; Or this function should do the same thing.
(defun yank-append-line (arg)
  "Copy lines (as many as prefix argument) to the kill ring, appending to the last kill."
  (interactive "p")
  (append-next-kill)
  (kill-ring-save (point)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(define-key global-map (kbd "M-k") 'yank-append-line)



;; this one takes .clj.html to blogger in clipboard
(fset 'clj-html-to-blogger-copy
   [?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-n ?\C-n ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?. ?c ?l ?o ?j ?u ?r ?e ?- ?\C-s ?/ ?h ?e ?a ?d ?\C-a ?\C-k ?\C-k ?\C-k ?\C-k ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?  ?c ?l ?a ?s ?s ?= ?\" ?c ?l ?o ?j ?u ?r ?e ?- ?b ?o ?o ?\C-? ?d ?y ?\" ?\C-n ?\M-> ?\C-p ?\C-p ?\C-k ?\C-k ?\C-k ?\C-k ?\C-x ?h ?\M-w])

;; keyboard macro of the gods:
;; evaluates the expression on the line BELOW, and pastes the result afterwards
(setq last-kbd-macro
  [down ?\C-a ?\C-\M-f ?  ?\; left ?\C-k ?\; ?  ?\C-u ?\C-x ?\C-e])

;; Compile and goto repl
(fset 'compile-and-goto-repl
   "\C-x\C-s\C-c\C-k\C-c\C-z")
;; would be great if we could also add C-c M-p to change package somehow
(global-set-key [f6] 'compile-and-goto-repl)


;;eval and move forwards
(fset 'running-eval
      "\M-\C-x\M-\C-e")
(global-set-key [f5] 'running-eval)
