;;; this was installed by package-install.el.
;;; This provides support for the package system and
;;; interfacing with ELPA, the package archive.
;;; Move this code earlier if you want to reference
;;; packages in your .emacs.
(when
    (load
     (expand-file-name "~/.emacs.d/elpa/package.el"))
  (package-initialize))

;;emacs color themes are in the package emacs-goodies-el on ubuntu
(require 'color-theme)
(color-theme-initialize)
;;here are the ones I find usable
(color-theme-billw)
;(color-theme-gtk-ide)
;(color-theme-katester)
;(color-theme-midnight)
;(color-theme-retro-green)
;(color-theme-retro-orange)
;(color-theme-scintilla)

;read desktop file from starting directory
;(desktop-save-mode t)

;;lisp editing is better with flashing brackets
(show-paren-mode)

;no line wrapping ;modified for dev8d
(setq-default truncate-lines nil)

;set fill column for netbook screen
(setq-default fill-column 80)

;sane scrolling
(setq scroll-conservatively 10000)

;stop messing about
(setq even-window-heights nil)

; make a copy for backup rather than moving the file and writing a new one.
; means that hard links survive editing.
(setq backup-by-copying t)

; make emacs use the clipboard
(setq x-select-enable-clipboard t)
(setq interprogram-paste-function 'x-cut-buffer-or-selection-value)

;make the set-fill-column key, which I never use, go away and stop
;interfering with C-x C-f for find-file
(global-set-key (kbd "C-x f") 'find-file)

;these only started working after I disabled all the GNOME A-C-arrow etc keys.
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)

;whitespace highlighting is useful for python, but annoying usually
;(global-whitespace-mode)

(setq-default indent-tabs-mode nil)

;; disable overwrite mode, so that accidentally hitting the insert key asks for
;; confirmation
(put 'overwrite-mode 'disabled t)

;; ========== Place Backup Files in Specific Directory ==========
;; Enable backup files.
(setq make-backup-files t)
;; Keep last five versions
(setq version-control t)
;; Save all backup file in this directory.
(setq backup-directory-alist (quote ((".*" . "~/.emacs_backups/"))))

;; Put the full path of the file being edited in the titlebar
(setq frame-title-format '("%b" (buffer-file-name ": %f")))

;; Save the history of kills, and searches
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq savehist-file "~/.emacs.d/tmp/savehist")
(savehist-mode t)

;; disable bell function
(setq ring-bell-function 'ignore)
;; disable toolbar
(tool-bar-mode -1)
;; disable scrollbar
(toggle-scroll-bar -1)
;; disable menu bar
;(menu-bar-mode -1)

;; disable splash screen and show unknown files in speedbar
(custom-set-variables
 '(inhibit-startup-screen t)
 '(speedbar-show-unknown-files t))

;; start emacs server
(server-start)

;; Unique names for buffers with identical filenames
; __init__.py, indeed
(require 'uniquify)
(setq uniquify-buffer-name-style 'reverse)   
(setq uniquify-separator "/")   
(setq uniquify-after-kill-buffer-p t) ; rename after killing uniquified   
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers 


;; Swap windows with C-x 8
;; stolen from Steve Yegge at http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun swap-windows ()
  "If you have 2 windows, it swaps them." 
  (interactive) 
  (cond ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
        (t
         (let* ((w1 (first (window-list)))
                (w2 (second (window-list)))
                (b1 (window-buffer w1))
                (b2 (window-buffer w2))
                (s1 (window-start w1))
                (s2 (window-start w2)))
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (set-window-start w1 s2)
           (set-window-start w2 s1)))))

(define-key global-map (kbd "C-x 8") 'swap-windows)

;; Dired command for finding all marked files, use F in dired mode
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))

;; I occasionally find myself needing to gather lines up one by one and paste
;; them all somewhere You can do C-space, end, Cxx, M-C-w, M-w to get an
;; appending yanking version of C-k Or this function should do the same thing.
(defun yank-append-line (arg)
  "Copy lines (as many as prefix argument) to the kill ring, appending to the last kill."
  (interactive "p")
  (append-next-kill)
  (kill-ring-save (point)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(define-key global-map (kbd "M-k") 'yank-append-line)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; python

;; use the version of python.el in fgallina's github repository
;; which should be a sub-repo of hobby-code:
;; cd ~/hobby-code &&  git://github.com/fgallina/python.el.git
(add-to-list 'load-path "~/python.el/")
(require 'python)

;; use python3.1
;(setq python-python-command "/usr/bin/python3.1")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Clojure-related stuff

;;bind the slime selector to f12 and add a method for finding clojure buffers
(require 'slime)
(define-key global-map (kbd "<f12>") 'slime-selector)
(def-slime-selector-method ?j
  "most recently visited clojure-mode buffer."
  (slime-recently-visited-buffer 'clojure-mode))

;;copy last expression to repl
(defun copy-last-expression-to-clojure-slime-repl()
  "copy-last-expression-to-clojure-slime-repl. Not very clever about it. Finds buffer by name."
  (interactive)
  (let((end (point))
       (beg (save-excursion
              (backward-list 1)
              (point)))
       (edit-buffer (current-buffer))
       (lisp-buffer (get-buffer "*slime-repl clojure*"))
       (eval-command 'slime-repl-return))
  (progn
     (pop-to-buffer lisp-buffer)
     (end-of-buffer)
     (pop-to-buffer edit-buffer)
     (append-to-buffer lisp-buffer beg end)
     (pop-to-buffer lisp-buffer)
     (funcall eval-command)
     (pop-to-buffer edit-buffer))))

(define-key global-map (kbd "C-x C-r") 'copy-last-expression-to-clojure-slime-repl)

;; rainbow brackets in clojure mode, relies on highlight-parentheses.el in 
;; ~/hobby-code
(add-to-list 'load-path "~/hobby-code")
(require 'highlight-parentheses)
(setq hl-paren-colors
      '("orange1" "yellow1" "greenyellow" "green1"
        "springgreen1" "cyan1" "slateblue1" "magenta1" "purple"))
(add-hook 'clojure-mode-hook 
          (lambda () (highlight-parentheses-mode t)))

;; this one takes .clj.html to blogger in clipboard
(fset 'clj-html-to-blogger-copy
   [?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-k ?\C-n ?\C-n ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?. ?c ?l ?o ?j ?u ?r ?e ?- ?\C-s ?/ ?h ?e ?a ?d ?\C-a ?\C-k ?\C-k ?\C-k ?\C-k ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?\C-f ?  ?c ?l ?a ?s ?s ?= ?\" ?c ?l ?o ?j ?u ?r ?e ?- ?b ?o ?o ?\C-? ?d ?y ?\" ?\C-n ?\M-> ?\C-p ?\C-p ?\C-k ?\C-k ?\C-k ?\C-k ?\C-x ?h ?\M-w])

;; keyboard macro of the gods:
;; evaluates the expression on the line BELOW, and pastes the result afterwards
(setq last-kbd-macro
  [down ?\C-a ?\C-\M-f ?  ?\; left ?\C-k ?\; ?  ?\C-u ?\C-x ?\C-e])

;; Compile and goto repl
(fset 'compile-and-goto-repl
   "\C-x\C-s\C-c\C-k\C-c\C-z")
;; would be great if we could also add C-c M-p to change package somehow
(global-set-key [f6] 'compile-and-goto-repl)


;;eval and move forwards
(fset 'running-eval
      "\M-\C-x\M-\C-e")
(global-set-key [f5] 'running-eval)






