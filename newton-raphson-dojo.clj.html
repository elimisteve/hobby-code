<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.34 in css mode. -->
<html>
  <head>
    <title>newton-raphson-dojo.clj</title>
    <style type="text/css">
    <!--
      body {
        color: #fff8dc;
        background-color: #000000;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .comment {
        /* font-lock-comment-face */
        color: #ffd700;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #ffd700;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #00fa9a;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="comment-delimiter">;; </span><span class="comment">When we write lisp, we have magic powers, and the reason is that our code is in a form that is easy to manipulate
</span><span class="comment-delimiter">;; </span><span class="comment">programmatically.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Like all magic, there is a price to pay.
</span>
<span class="comment-delimiter">;; </span><span class="comment">The price is that we have to rip the front end off our compiler.
</span>
<span class="comment-delimiter">;; </span><span class="comment">The front end is the thing that takes 1*2+3*5 and says
</span>
<span class="comment-delimiter">;; </span><span class="comment">1 is valid but 1* isn't , and so on, so that must really be 1 * 2 + 3 * 5 
</span><span class="comment-delimiter">;; </span><span class="comment">* binds tighter than +, so that's really ( ( 1 * 2 ) + ( 3 * 5 ) )
</span><span class="comment-delimiter">;; </span><span class="comment">Which is really a tree:
</span>
             (+ 
              (* 5 3)
              (* 1 2))

<span class="comment-delimiter">;; </span><span class="comment">Meaning take 1 and 2 and multiply them, take 5 and 3 and multiply them. Add the results.
</span>
<span class="comment-delimiter">;; </span><span class="comment">This is clearly seriously annoying, and like monads in Haskell, it's the first thing you hit when you learn lisp, 
</span><span class="comment-delimiter">;; </span><span class="comment">but I promise that after a month or so of using it you stop noticing it, 
</span><span class="comment-delimiter">;; </span><span class="comment">and although it's never quite as good for actual arithmetic, it's actually much nicer as a notation for a 
</span><span class="comment-delimiter">;; </span><span class="comment">generalized function call.
</span>
<span class="comment-delimiter">;; </span><span class="comment">More importantly, it allows us to treat all functions uniformly, including the ones we define 
</span><span class="comment-delimiter">;; </span><span class="comment">ourselves. And this is the source of the magic.
</span>
<span class="comment-delimiter">;; </span><span class="comment">If we do well today we'll be able to symbolically differentiate a function. Using a very short program. 
</span><span class="comment-delimiter">;; </span><span class="comment">And that's hard in a language with a syntax.
</span>
<span class="comment-delimiter">;; </span><span class="comment">So my aim for today is to get us used to the (lack of) syntax of lisp. 
</span>
<span class="comment-delimiter">;; </span><span class="comment">We're going to use clojure, which is a modern member of the LISP family, 
</span><span class="comment-delimiter">;; </span><span class="comment">in the same sense that Java is a member of the ALGOL family.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Clojure's a wonderful language, which uses Java bytecode as its machine language, and runs on the JVM, 
</span><span class="comment-delimiter">;; </span><span class="comment">and so has easy natural access to all the libraries that Java has. 
</span>
<span class="comment-delimiter">;; </span><span class="comment">My friends at the Chemistry department in Cambridge are using it because they've written a lot of Java over the years, 
</span><span class="comment-delimiter">;; </span><span class="comment">and they like it, but they've found that Clojure is an easier way to write Java than Java is.
</span>
<span class="comment-delimiter">;; </span><span class="comment">It has pervasive laziness throughout the language, which allows us to 
</span><span class="comment-delimiter">;; </span><span class="comment">disconnect the things that need to be done from the order they need to be done in.  
</span><span class="comment-delimiter">;; </span><span class="comment">It has extraordinary pure-functional data structures, and baked-in software transactional memory, 
</span><span class="comment-delimiter">;; </span><span class="comment">which together make for a style of programming that can run in parallel on many cores.
</span>
<span class="comment-delimiter">;; </span><span class="comment">But I'm going to ignore all of that, and we're going to get over the pons asinorum of lisp, 
</span><span class="comment-delimiter">;; </span><span class="comment">which is all those damned brackets.
</span>
<span class="comment-delimiter">;; </span><span class="comment">We're going to write a program that you could have written in lisp forty years ago, when the newest member 
</span><span class="comment-delimiter">;; </span><span class="comment">of the ALGOL family was ALGOL itself.
</span>

<span class="comment-delimiter">;; </span><span class="comment">-------------------------------------------------------------------------------------------------
</span>
<span class="comment-delimiter">;; </span><span class="comment">The method of Heron of Alexandria
</span><span class="comment-delimiter">;; </span><span class="comment">---------------------------------
</span>
<span class="comment-delimiter">;; </span><span class="comment">I don't know if any of you remember not having a calculator. 
</span><span class="comment-delimiter">;; </span><span class="comment">Once upon a time they didn't even have mathematical tables, and so they had to calculate things like square roots by hand.
</span>
<span class="comment-delimiter">;; </span><span class="comment">One popular method of calculating a square root is due to Hero(n) of Alexandria, 
</span><span class="comment-delimiter">;; </span><span class="comment">who also invented steam power, the windmill, the syringe and the vending machine.
</span>
<span class="comment-delimiter">;; </span><span class="comment">What Heron said to do was this:
</span>
<span class="comment-delimiter">;; </span><span class="comment">Suppose you have a number that you want to find the square root of, let's say 10.
</span>
<span class="comment-delimiter">;; </span><span class="comment">And suppose you have a guess for where that square root might be, let's say 1. 
</span><span class="comment-delimiter">;; </span><span class="comment">It's not a very good guess, because the square of 1 is 1, not ten, but it will do to get started.
</span>
<span class="comment-delimiter">;; </span><span class="comment">So Heron tells us, if we know the square root, then if we divide 10 by it, we'll get it back.
</span><span class="comment-delimiter">;; </span><span class="comment">Like say the square root of 4 is 2, and if we divide 4 by 2, then we get 2. 
</span><span class="comment-delimiter">;; </span><span class="comment">And that's what it means to *be* a square root.
</span>
<span class="comment-delimiter">;; </span><span class="comment">But if we guessed too low, then the thing we get back will be too high.
</span><span class="comment-delimiter">;; </span><span class="comment">And if it's too high, then the thing that we get back will be too low.
</span>
<span class="comment-delimiter">;; </span><span class="comment">So Heron says to take the average of what we have and what we get back when we do this division, 
</span><span class="comment-delimiter">;; </span><span class="comment">and he promises us that will be a better guess.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Let's try that, for our problem number 10, and our guess 1
</span>user&gt; (/ 10 1)
10

<span class="comment-delimiter">;; </span><span class="comment">We guessed 1, we divided 10 by 1, we got back 10.
</span><span class="comment-delimiter">;; </span><span class="comment">What's the average?
</span>user&gt; (/ (+ 10 1) 2)
11/2 

<span class="comment-delimiter">;; </span><span class="comment">Or if we do the whole calculation at once, it looks like:
</span>user&gt; (/ (+ (/ 10 1) 1) 2)
11/2

<span class="comment-delimiter">;; </span><span class="comment">That's getting a bit hard to read, so we should define a function to give us averages
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">average</span> [a b] (/ (+ a b) 2))
#'user/average

<span class="comment-delimiter">;; </span><span class="comment">We can test it
</span>user&gt; (average 10 1)
11/2

<span class="comment-delimiter">;; </span><span class="comment">So our old calculation goes like
</span>user&gt; (average (/ 10 1) 1)
11/2

<span class="comment-delimiter">;; </span><span class="comment">We might as well make another function which just makes our guesses better.
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">improve-guess</span> [guess] (average guess (/ 10 guess)))
#'user/improve-guess

<span class="comment-delimiter">;; </span><span class="comment">Let's try that
</span>user&gt; (improve-guess 1)
11/2

<span class="comment-delimiter">;; </span><span class="comment">Of course, a better guess can also be improved
</span>user&gt; (improve-guess (improve-guess 1))
161/44

<span class="comment-delimiter">;; </span><span class="comment">And improved again
</span>user&gt; (improve-guess (improve-guess (improve-guess 1)))
45281/14168

<span class="comment-delimiter">;; </span><span class="comment">Now you'll notice that clojure is doing exact arithmetic, and giving us back a fraction, just like a human being would do. 
</span><span class="comment-delimiter">;; </span><span class="comment">But if we start it off with an inexact guess, a decimal rather than a rato, say 1.0 rather than 1
</span><span class="comment-delimiter">;; </span><span class="comment">Then because you can't make an exact answer from an inexact input, every answer we get back will be a decimal.
</span>user&gt; (improve-guess (improve-guess (improve-guess 1.0)))
3.196005081874647

<span class="comment-delimiter">;; </span><span class="comment">inexactness is contagious.
</span>user&gt; (+ 1 2)
3
user&gt; (+ 1.0 2)
3.0

<span class="comment-delimiter">;; </span><span class="comment">Let's go on a bit of a side-track now and look at just how good Heron's great idea is. We can use a magic function called 
</span><span class="comment-delimiter">;; </span><span class="comment">iterate to make an infinite sequence of guesses. It's best only to look at the first bit of an infinite sequence. 
</span><span class="comment-delimiter">;; </span><span class="comment">Otherwise, like with the Medusa of Greek myth, the REPL turns to stone. Let's look at the first five values in our
</span><span class="comment-delimiter">;; </span><span class="comment">sequence.
</span>user&gt; (<span class="builtin">take</span> 5 (<span class="builtin">iterate</span> improve-guess 1))
(1 11/2 161/44 45281/14168 4057691201/1283082416)

<span class="comment-delimiter">;; </span><span class="comment">We get a better idea of what's going on here if we use decimal fractions
</span>user&gt; (<span class="builtin">take</span> 5 (<span class="builtin">iterate</span> improve-guess 1.))
(1.0 5.5 3.659090909090909 3.196005081874647 3.16245562280389)

<span class="comment-delimiter">;; </span><span class="comment">It only takes a few iterations before we've hit the limit of floating-point accuracy
</span>user&gt; (<span class="builtin">take</span> 10 (<span class="builtin">iterate</span> improve-guess 1.))
(1.0 5.5 3.659090909090909 3.196005081874647 3.16245562280389 3.162277665175675 3.162277660168379 3.162277660168379 3.162277660168379 3.162277660168379)

<span class="comment-delimiter">;; </span><span class="comment">Let's look at the squares of the values in our sequence:
</span>user&gt; (<span class="builtin">map</span> (fn[x](* x x)) (<span class="builtin">iterate</span> improve-guess 1.))
<span class="comment-delimiter">;; </span><span class="comment">Oops. We looked at the medusa! In some environments the REPL is smart enough to print out the values one-by-one, 
</span><span class="comment-delimiter">;; </span><span class="comment">but here, it's trying to do the whole thing before printing anything.
</span><span class="comment-delimiter">;; </span><span class="comment">Ctrl-C will stop the calculation and restore the REPL.
</span>
<span class="comment-delimiter">; </span><span class="comment">Evaluation aborted.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Try again:
</span>user&gt; (<span class="builtin">take</span> 10 (<span class="builtin">map</span> (fn[x](* x x)) (<span class="builtin">iterate</span> improve-guess 1.)))
(1.0 30.25 13.388946280991735 10.21444848336857 10.001125566203939 10.000000031668918 9.999999999999998 9.999999999999998 9.999999999999998 9.999999999999998)

<span class="comment-delimiter">;; </span><span class="comment">But iterate and map are magic functions, so let's not worry too much about lazy sequences just yet, and see how we might do it the hard way.
</span>
<span class="comment-delimiter">;; </span><span class="comment">First off, we'd like a definition of when our guess is good enough.
</span><span class="comment-delimiter">;; </span><span class="comment">How about, square it and if the answer's close to 10 then that goes?
</span><span class="comment-delimiter">;; </span><span class="comment">How good a guess is 3.19?
</span>user&gt; (- 10 (* 3.19 3.19))
-0.17609999999999992

<span class="comment-delimiter">;; </span><span class="comment">Rats, we need an absolute value function
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">abs</span>[x] (<span class="keyword">if</span> (&lt; x 0) -x x))
<span class="comment-delimiter">; </span><span class="comment">Barf....
</span>
<span class="comment-delimiter">; </span><span class="comment">Sigh. Every function needs the same call syntax. Unary minus is a function just like anything else.
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">abs</span>[x] (<span class="keyword">if</span> (&lt; x 0) (- x) x))
#'user/abs

<span class="comment-delimiter">; </span><span class="comment">Let's use map to test the function.
</span>user&gt; (<span class="builtin">map</span> abs (list -1 1 0))
(1 1 0)

<span class="comment-delimiter">;; </span><span class="comment">So:
</span>user&gt; (abs (- 10 (* 3.19 3.19)))
0.17609999999999992

<span class="comment-delimiter">;; </span><span class="comment">What's good enough? Say if the difference is less than 1/10^6, or 1e-6
</span>user&gt; 1e-6
1.0E-6

<span class="comment-delimiter">;; </span><span class="comment">Here's our good-enough test
</span>user&gt; (&lt; (abs (- 10 (* 3.19 3.19))) 1e-6)
false
<span class="comment-delimiter">;; </span><span class="comment">3.19 isn't good enough
</span>
<span class="comment-delimiter">;; </span><span class="comment">Wrap the test up
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">good-enough?</span> [guess] (&lt; (abs (- 10 (* guess guess))) 1e-6))
#'user/good-enough?

<span class="comment-delimiter">;; </span><span class="comment">Let's see whether the first five values are good enough
</span>user&gt; (<span class="builtin">take</span> 5 (<span class="builtin">map</span> good-enough? (<span class="builtin">iterate</span> improve-guess 1.)))
(false false false false false)

<span class="comment-delimiter">;; </span><span class="comment">What about the first ten?
</span>user&gt; (<span class="builtin">take</span> 10 (<span class="builtin">map</span> good-enough? (<span class="builtin">iterate</span> improve-guess 1.)))
(false false false false false true true true true true)

<span class="comment-delimiter">;; </span><span class="comment">What were those answers again?
</span>user&gt; (<span class="builtin">take</span> 10 (<span class="builtin">iterate</span> improve-guess 1.))
(1.0 5.5 3.659090909090909 3.196005081874647 3.16245562280389 3.162277665175675 3.162277660168379 3.162277660168379 3.162277660168379 3.162277660168379)

<span class="comment-delimiter">;; </span><span class="comment">So what if we just want a function that will give us an answer that is good enough?
</span><span class="comment-delimiter">;; </span><span class="comment">We'll call it good-enough-guess. We give it a guess. If that guess is good enough, then it gives us it back.
</span><span class="comment-delimiter">;; </span><span class="comment">If it's not, then it makes it better, and tries again.
</span>user&gt; (<span class="keyword">defn</span> <span class="function-name">good-enough-guess</span> [x]
        (<span class="keyword">if</span> (good-enough? x) x
            (good-enough-guess (improve-guess x))))
#'user/good-enough-guess

<span class="comment-delimiter">;; </span><span class="comment">It doesn't really matter what our initial guess is. Anything will work.
</span>user&gt; (good-enough-guess 1.0)
3.162277665175675

user&gt; (good-enough-guess 3.0)
3.162277660169842

<span class="comment-delimiter">;; </span><span class="comment">How good is that guess?
</span>user&gt; (* (good-enough-guess 3.0)(good-enough-guess 3.0))
10.00000000000925

<span class="comment-delimiter">;; </span><span class="comment">Sweet. Here endeth the method of Heron of Alexandria for finding the square root of 10.
</span>
<span class="comment-delimiter">;; </span><span class="comment">Let's have a look at our program in its entirety
</span>
<span class="comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="comment">
</span>
(<span class="keyword">defn</span> <span class="function-name">average</span> [a b] 
  (/ (+ a b) 2))

(<span class="keyword">defn</span> <span class="function-name">improve-guess</span> [guess]
  (average guess (/ 10 guess)))

(<span class="keyword">defn</span> <span class="function-name">abs</span>[x] 
  (<span class="keyword">if</span> (&lt; x 0) (- x) x))

(<span class="keyword">defn</span> <span class="function-name">good-enough?</span> [guess] 
  (&lt; (abs (- 10 (* guess guess))) 1e-6))

(<span class="keyword">defn</span> <span class="function-name">good-enough-guess</span> [x]
  (<span class="keyword">if</span> (good-enough? x) x
      (good-enough-guess (improve-guess x))))

<span class="comment-delimiter">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="comment">
</span>

</pre>
  </body>
</html>
